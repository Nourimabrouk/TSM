h[1] <- c/(1 - T)
P[1] <- Q/(1 - T^2)
for (t in 1:n) {
#print(cbind(x[t], h[t], y[t]))
v[t] <- (y[t] - d) - Z*h[t] - x[t]*Beta
F[t] <- Z^2*P[t] + H
K[t] <- T*(P[t]/F[t])
h_t[t] <- h[t] + P[t]*Z*v[t]/F[t]
P_t[t] <- P[t] - (P[t]^2)*(Z^2)/F[t]
if(t < n-1){
h[t+1] <- c + T*h_t[t]
P[t+1] <- T^2*P_t[t] + Q*(R^2)
}
output_kalmanfilter <- data.frame(h, P, v, F, K)
return(output_kalmanfilter)
}
perform_QML_routine = function(returns, stockdata){
# Create transformed data matrix
y = diff(log(stockdata$Close))
x <- log((y - mean(y))^2)
rv <- stockdata$RV[-1]
input_matrix_stocks <- cbind(x, rv)
input_returns <- returns$transformed
# Initialise parameters
sig_eps <- (pi^2)/2 # Given in assignment
mean_u <- -1.27 # Given in assignment
par_ini <- c(0.1082, 0.991, -0.207, 0.0)
Beta <- 0
state_space_parameters <- data.frame(
Q = 1,
Z = 1,
H = sig_eps,
R = par_ini[1],
T = par_ini[2],
c = par_ini[3],
d = mean_u,
Beta = par_ini[4]
)
params_returns <- optimize_parameters(input_returns, par_ini, state_space_parameters, TRUE) # (Print_output = TRUE)
params_stocks <- optimize_parameters(input_matrix_stocks, par_ini, state_space_parameters, TRUE)
stock_data <- cbind(x, stockdata$RV[-1])
ret_trans <- returns$transformed
outputKalman_returns <- compute_kalmanfilter(input_returns, params_returns, state_space_parameters)
outputSmooth_returns <- compute_smoothed_state(input_returns, params_returns, outputKalman_returns)
outputKalman_stocks <- compute_kalmanfilter(input_matrix_stocks[,1], params_stocks, state_space_parameters)
outputSmooth_stocks <- compute_smoothed_state(input_matrix_stocks[,1],params_stocks, outputKalman_stocks)
}
compute_smoothed_state <- function(data, theta, kf){
y <- as.matrix(data)
h <- kf$h
P <- kf$P
v <- kf$v
F <- kf$F
K <- kf$K
phi <- theta[2]
Z <- 1
n <- length(v)
alpha <- rep(0, n) # smoothed stated
N <- rep(0, n)     # smoothed state error variance
r <- rep(0, n)
V <- rep(0, n)     # smoothed state variance
L <- phi-K*Z
N[n] <- 0
r[n] <- 0
for (j in (n):2){ #backward recursion
N[j-1] <- (1/F[j]) + (L[j]^2) * N[j]
V[j] <- P[j] - (P[j]^2)*N[j-1]
if (is.nan(y[j]) || is.na(y[j])){
N[j-1] <- N[j]
V[j] <- P[j] - (P[j]^2)*N[j-1]
r[j-1] <- r[j]
}
else {
r[j-1] <- (v[j]/F[j]) + L[j]*r[j]
}
alpha[j] <- h[j] + P[j]*r[j-1]
}
N[1] <- (1/F[2]) + (L[2]^2) * N[2]
N_0 <- (1/F[1]) + (L[1]^2) * N[1]
V[1] <- P[1] - (P[1]^2)*N_0
r_0 <- (v[1]/F[1]) + L[1]*r[1]
alpha[1] <- h[1] + P[1]*r_0
Smoothedstate <- data.frame(alpha, r, N, V)
return (Smoothedstate)
}
rm(list=ls())
# Imports ----------
source("functions.R")
#source("Plotting.R")
library(here)
library(tidyverse)
library(tsibble)
library(lubridate)
library(scales)
library(ggplot2)
library(fable)
setwd(here())
options(warn=-1)
# Data import & cleaning --------
data <- read.delim(here('Data', 'sv.dat'))
stocks <- read_csv(here('Data', 'oxfordmanrealizedvolatilityindices.csv'))
returns <- data %>%
mutate(index = 1:nrow(data)) %>%
relocate(index) %>%
as_tsibble(index = index) %>%
rename(x = X...Pound.Dollar.daily.exchange.rates..sections.9.6.and.14.4) %>%
mutate(demeaned = (x - mean(x))/100,
transformed = log(demeaned^2))
stockdata <- stocks %>%
filter(Symbol == ".SPX" & year(X1) > 2015) %>%
select(X1,close_price, rk_parzen) %>% # replace rk_parzen with realized volatility measure of choice
rename(Date = X1, Close = close_price, RV = rk_parzen) %>%
mutate(RV = log(RV)) %>%
as_tsibble()
perform_QML_routine(returns, stockdata)
outputKalman_stocks
print(outputKalman_stocks)
perform_QML_routine = function(returns, stockdata){
# Create transformed data matrix
y = diff(log(stockdata$Close))
x <- log((y - mean(y))^2)
rv <- stockdata$RV[-1]
input_matrix_stocks <- cbind(x, rv)
input_returns <- returns$transformed
# Initialise parameters
sig_eps <- (pi^2)/2 # Given in assignment
mean_u <- -1.27 # Given in assignment
par_ini <- c(0.1082, 0.991, -0.207, 0.0)
Beta <- 0
state_space_parameters <- data.frame(
Q = 1,
Z = 1,
H = sig_eps,
R = par_ini[1],
T = par_ini[2],
c = par_ini[3],
d = mean_u,
Beta = par_ini[4]
)
params_returns <- optimize_parameters(input_returns, par_ini, state_space_parameters, TRUE) # (Print_output = TRUE)
params_stocks <- optimize_parameters(input_matrix_stocks, par_ini, state_space_parameters, TRUE)
stock_data <- cbind(x, stockdata$RV[-1])
ret_trans <- returns$transformed
outputKalman_returns <- compute_kalmanfilter(input_returns, params_returns, state_space_parameters)
outputSmooth_returns <- compute_smoothed_state(input_returns, params_returns, outputKalman_returns)
outputKalman_stocks <- compute_kalmanfilter(input_matrix_stocks[,1], params_stocks, state_space_parameters)
outputSmooth_stocks <- compute_smoothed_state(input_matrix_stocks[,1],params_stocks, outputKalman_stocks)
print(outputKalman_stocks)
}
rm(list=ls())
# Imports ----------
source("functions.R")
#source("Plotting.R")
library(here)
library(tidyverse)
library(tsibble)
library(lubridate)
library(scales)
library(ggplot2)
library(fable)
setwd(here())
options(warn=-1)
# Data import & cleaning --------
data <- read.delim(here('Data', 'sv.dat'))
stocks <- read_csv(here('Data', 'oxfordmanrealizedvolatilityindices.csv'))
returns <- data %>%
mutate(index = 1:nrow(data)) %>%
relocate(index) %>%
as_tsibble(index = index) %>%
rename(x = X...Pound.Dollar.daily.exchange.rates..sections.9.6.and.14.4) %>%
mutate(demeaned = (x - mean(x))/100,
transformed = log(demeaned^2))
stockdata <- stocks %>%
filter(Symbol == ".SPX" & year(X1) > 2015) %>%
select(X1,close_price, rk_parzen) %>% # replace rk_parzen with realized volatility measure of choice
rename(Date = X1, Close = close_price, RV = rk_parzen) %>%
mutate(RV = log(RV)) %>%
as_tsibble()
perform_QML_routine(returns, stockdata)
return(list(stock_data, ret_trans))
transform_data <- function(stockdata, returns){
y = diff(log(stockdata$Close))
x <- log((y - mean(y))^2)
rv <- stockdata$RV[-1]
input_matrix_stocks <- cbind(x, rv)
input_returns <- returns$transformed
stock_data <- cbind(x, stockdata$RV[-1])
ret_trans <- returns$transformed
return(list(stock_data, ret_trans))
}
transform_data(stockdata,returns)
return(c(stock_data, ret_trans))
return(cbind(stock_data, ret_trans))
transform_data <- function(stockdata, returns){
y = diff(log(stockdata$Close))
x <- log((y - mean(y))^2)
rv <- stockdata$RV[-1]
input_matrix_stocks <- cbind(x, rv)
input_returns <- returns$transformed
stock_data <- cbind(x, stockdata$RV[-1])
ret_trans <- returns$transformed
return(cbind(stock_data, ret_trans))
}
return(cbind(stock_data, ret_trans))
transform_data(stockdata, returns)
return(list(state_space_parameters, par_ini))
initialise_parameters_QML <- function(){
sig_eps <- (pi^2)/2 # Given in assignment
mean_u <- -1.27 # Given in assignment
par_ini <- c(0.1082, 0.991, -0.207, 0.0)
Beta <- 0
state_space_parameters <- data.frame(
Q = 1,
Z = 1,
H = sig_eps,
R = par_ini[1],
T = par_ini[2],
c = par_ini[3],
d = mean_u,
Beta = par_ini[4]
)
return(list(state_space_parameters, par_ini))
}
initialise_parameters_QML
initialise_parameters_QML <- function(){
sig_eps <- (pi^2)/2 # Given in assignment
mean_u <- -1.27 # Given in assignment
par_ini <- c(0.1082, 0.991, -0.207, 0.0)
Beta <- 0
state_space_parameters <- data.frame(
Q = 1,
Z = 1,
H = sig_eps,
R = par_ini[1],
T = par_ini[2],
c = par_ini[3],
d = mean_u,
Beta = par_ini[4]
)
return(list(state_space_parameters, par_ini))
}
initialise_parameters_QML
initialise_parameters_QML()
initialise_parameters_QML()[[1]]
state_space_parameters, par_ini = initialise_parameters_QML
state_space_parameters, par_ini = initialise_parameters_QML()
list(state_space_parameters, par_ini) = initialise_parameters_QML()
c(state_space_parameters, par_ini) = initialise_parameters_QML()
initialise_parameters_QML <- function(){
sig_eps <- (pi^2)/2 # Given in assignment
mean_u <- -1.27 # Given in assignment
par_ini <- c(0.1082, 0.991, -0.207, 0.0)
Beta <- 0
state_space_parameters <- data.frame(
Q = 1,
Z = 1,
H = sig_eps,
R = par_ini[1],
T = par_ini[2],
c = par_ini[3],
d = mean_u,
Beta = par_ini[4]
)
return(list(state_space_parameters, par_ini))
}
list[state_space_parameters, par_ini] = initialise_parameters_QML()
initial_parameters = initialise_parameters_QML()
par_ini = initial_parameters[1]
par_ini = initial_parameters[[1]]
state_space_parameters = initial_parameters[[1]]
par_ini = initial_parameters[[2]]
transform_data(stockdata, returns)
transformed_df = transform_data(stockdata, returns)
return(list(stock_data, ret_trans))
transform_data <- function(stockdata, returns){
y = diff(log(stockdata$Close))
x <- log((y - mean(y))^2)
rv <- stockdata$RV[-1]
input_matrix_stocks <- cbind(x, rv)
input_returns <- returns$transformed
stock_data <- cbind(x, stockdata$RV[-1])
ret_trans <- returns$transformed
return(list(stock_data, ret_trans))
}
transformed_df = transform_data(stockdata, returns)
transformed_df
transformed_df[[1]]
input_returns = transformed_df[[2]]
initial_parameters = initialise_parameters_QML()
state_space_parameters = initial_parameters[[1]]
par_ini = initial_parameters[[2]]
initialise_parameters_QML <- function(){
sig_eps <- (pi^2)/2 # Given in assignment
mean_u <- -1.27 # Given in assignment
par_ini <- c(0.1082, 0.991, -0.207, 0.0)
Beta <- 0
state_space_parameters <- data.frame(
Q = 1,
Z = 1,
H = sig_eps,
R = par_ini[1],
T = par_ini[2],
c = par_ini[3],
d = mean_u,
Beta = par_ini[4]
)
return(list(state_space_parameters, par_ini))
}
transform_data <- function(stockdata, returns){
y = diff(log(stockdata$Close))
x <- log((y - mean(y))^2)
rv <- stockdata$RV[-1]
input_matrix_stocks <- cbind(x, rv)
input_returns <- returns$transformed
stock_data <- cbind(x, stockdata$RV[-1])
ret_trans <- returns$transformed
return(list(stock_data, ret_trans))
}
transformed_df = transform_data(stockdata, returns)
input_stocks = transformed_df[[1]]
input_returns = transformed_df[[2]]
initial_parameters = initialise_parameters_QML()
state_space_parameters = initial_parameters[[1]]
par_ini = initial_parameters[[2]]
QML_params_returns <- optimize_parameters(input_returns, par_ini, state_space_parameters, TRUE) # (Print_output = TRUE)
outputKalman_returns <- compute_kalmanfilter(input_returns, QML_params_returns, state_space_parameters)
outputSmooth_returns <- compute_smoothed_state(input_returns, QML_params_returns, outputKalman_returns)
QML_params_stocks <- optimize_parameters(input_stocks, par_ini, state_space_parameters, TRUE)
outputKalman_stocks <- compute_kalmanfilter(input_stocks[,1], QML_params_stocks, state_space_parameters)
outputSmooth_stocks <- compute_smoothed_state(input_stocks[,1],QML_params_stocks, outputKalman_stocks)
transform_data <- function(stockdata, returns){
y = diff(log(stockdata$Close))
x <- log((y - mean(y))^2)
rv <- stockdata$RV[-1]
input_matrix_stocks <- cbind(x, rv)
input_returns <- returns$transformed
stock_data <- cbind(x, stockdata$RV[-1])
ret_trans <- returns$transformed
return(list(stock_data, ret_trans))
}
outputSmooth_stocks
rm(list=ls())
source("functions.R")
library(here)
library(tidyverse)
library(tsibble)
library(lubridate)
library(scales)
library(ggplot2)
library(fable)
setwd(here())
options(warn=-1)
data <- read.delim(here('Data', 'sv.dat'))
stocks <- read_csv(here('Data', 'oxfordmanrealizedvolatilityindices.csv'))
returns <- data %>%
mutate(index = 1:nrow(data)) %>%
relocate(index) %>%
as_tsibble(index = index) %>%
rename(x = X...Pound.Dollar.daily.exchange.rates..sections.9.6.and.14.4) %>%
mutate(demeaned = (x - mean(x))/100,
transformed = log(demeaned^2))
stockdata <- stocks %>%
filter(Symbol == ".SPX" & year(X1) > 2015) %>%
select(X1,close_price, rk_parzen) %>% # replace rk_parzen with realized volatility measure of choice
rename(Date = X1, Close = close_price, RV = rk_parzen) %>%
mutate(RV = log(RV)) %>%
as_tsibble()
transformed_df = transform_data(stockdata, returns)
input_stocks = transformed_df[[1]]
input_returns = transformed_df[[2]]
initial_parameters = initialise_parameters_QML()
state_space_parameters = initial_parameters[[1]]
par_ini = initial_parameters[[2]]
QML_params_returns <- optimize_parameters(input_returns, par_ini, state_space_parameters, TRUE) # (Print_output = TRUE)
outputKalman_returns <- compute_kalmanfilter(input_returns, QML_params_returns, state_space_parameters)
outputSmooth_returns <- compute_smoothed_state(input_returns, QML_params_returns, outputKalman_returns)
QML_params_stocks <- optimize_parameters(input_stocks, par_ini, state_space_parameters, TRUE)
outputKalman_stocks <- compute_kalmanfilter(input_stocks[,1], QML_params_stocks, state_space_parameters)
outputSmooth_stocks <- compute_smoothed_state(input_stocks[,1],QML_params_stocks, outputKalman_stocks)
outputSmooth_stocks
rm(list=ls())
# Imports ----------
source("functions.R")
#source("Plotting.R")
library(here)
library(tidyverse)
library(tsibble)
library(lubridate)
library(scales)
library(ggplot2)
library(fable)
setwd(here())
options(warn=-1)
# Data import & cleaning --------
data <- read.delim(here('Data', 'sv.dat'))
stocks <- read_csv(here('Data', 'oxfordmanrealizedvolatilityindices.csv'))
returns <- data %>%
mutate(index = 1:nrow(data)) %>%
relocate(index) %>%
as_tsibble(index = index) %>%
rename(x = X...Pound.Dollar.daily.exchange.rates..sections.9.6.and.14.4) %>%
mutate(demeaned = (x - mean(x))/100,
transformed = log(demeaned^2))
stockdata <- stocks %>%
filter(Symbol == ".SPX" & year(X1) > 2015) %>%
select(X1,close_price, rk_parzen) %>% # replace rk_parzen with realized volatility measure of choice
rename(Date = X1, Close = close_price, RV = rk_parzen) %>%
mutate(RV = log(RV)) %>%
as_tsibble()
transformed_df = transform_data(stockdata, returns)
input_stocks = transformed_df[[1]]
input_returns = transformed_df[[2]]
initial_parameters = initialise_parameters_QML()
state_space_parameters = initial_parameters[[1]]
par_ini = initial_parameters[[2]]
QML_params_returns <- optimize_parameters(input_returns, par_ini, state_space_parameters, TRUE) # (Print_output = TRUE)
outputKalman_returns <- compute_kalmanfilter(input_returns, QML_params_returns, state_space_parameters)
outputSmooth_returns <- compute_smoothed_state(input_returns, QML_params_returns, outputKalman_returns)
QML_params_stocks <- optimize_parameters(input_stocks, par_ini, state_space_parameters, TRUE)
outputKalman_stocks <- compute_kalmanfilter(input_stocks[,1], QML_params_stocks, state_space_parameters)
outputSmooth_stocks <- compute_smoothed_state(input_stocks[,1],QML_params_stocks, outputKalman_stocks)
for (t in 1:n) {
values = draw_values(n, sigma_eta, phi) # Vector of length n : theta_0 as random sample from normal unconditional distribution of theta
normalised_weights = compute_normalised_weights(sigma, theta_t, y_t)
c(att, ptt) = compute_att_ptt(theta_t, normalised_weights)
a_t = resampling(att)
return(a_t)
}
perform_particlefilter_routine <- function(input){
# Implementation from 14.5.3 DK
# With bootstrap filter
# And pg284 resampling
n = 100
sigma_eta = .5
phi = .5
for (t in 1:n) {
values = draw_values(n, sigma_eta, phi) # Vector of length n : theta_0 as random sample from normal unconditional distribution of theta
normalised_weights = compute_normalised_weights(sigma, theta_t, y_t)
c(att, ptt) = compute_att_ptt(theta_t, normalised_weights)
a_t = resampling(att)
return(a_t)
}
#f
n = 100; sigma_eta = .5; phi = .5
#f
n = 100; sigma_eta = .5; phi = .5
sigma = 1, theta_t = 1, y_t = 1 # change
perform_particlefilter_routine(n, sigma_eta, phi, sigma, theta_t, y_t)
sigma = 1, theta_t = 1, y_t = 1 # change
#f
n = 100; sigma_eta = .5; phi = .5
sigma = 1; theta_t = 1; y_t = 1 # change
perform_particlefilter_routine(n, sigma_eta, phi, sigma, theta_t, y_t)
perform_particlefilter_routine <- function(n, sigma_eta, phi, sigma, theta_t, y_t){
# Implementation from 14.5.3 DK
# With bootstrap filter
# And pg284 resampling
for (t in 1:n) {
values = draw_values(n, sigma_eta, phi) # Vector of length n : theta_0 as random sample from normal unconditional distribution of theta
normalised_weights = compute_normalised_weights(sigma, theta_t, y_t)
c(att, ptt) = compute_att_ptt(theta_t, normalised_weights)
a_t = resampling(att)
return(a_t)
}
rm(list=ls())
# Imports ----------
source("functions.R")
#source("Plotting.R")
library(here)
library(tidyverse)
library(tsibble)
library(lubridate)
library(scales)
library(ggplot2)
library(fable)
setwd(here())
options(warn=-1)
# Data import & cleaning --------
data <- read.delim(here('Data', 'sv.dat'))
stocks <- read_csv(here('Data', 'oxfordmanrealizedvolatilityindices.csv'))
returns <- data %>%
mutate(index = 1:nrow(data)) %>%
relocate(index) %>%
as_tsibble(index = index) %>%
rename(x = X...Pound.Dollar.daily.exchange.rates..sections.9.6.and.14.4) %>%
mutate(demeaned = (x - mean(x))/100,
transformed = log(demeaned^2))
stockdata <- stocks %>%
filter(Symbol == ".SPX" & year(X1) > 2015) %>%
select(X1,close_price, rk_parzen) %>% # replace rk_parzen with realized volatility measure of choice
rename(Date = X1, Close = close_price, RV = rk_parzen) %>%
mutate(RV = log(RV)) %>%
as_tsibble()
# ab
transformed_df = transform_data(stockdata, returns)
input_stocks = transformed_df[[1]]
input_returns = transformed_df[[2]]
#c / e -> need to separate these?
initial_parameters = initialise_parameters_QML()
state_space_parameters = initial_parameters[[1]]
par_ini = initial_parameters[[2]]
QML_params_returns <- optimize_parameters(input_returns, par_ini, state_space_parameters, TRUE) # (Print_output = TRUE)
QML_params_stocks <- optimize_parameters(input_stocks, par_ini, state_space_parameters, TRUE)
#d
outputKalman_returns <- compute_kalmanfilter(input_returns, QML_params_returns, state_space_parameters)
outputSmooth_returns <- compute_smoothed_state(input_returns, QML_params_returns, outputKalman_returns)
outputKalman_stocks <- compute_kalmanfilter(input_stocks[,1], QML_params_stocks, state_space_parameters)
outputSmooth_stocks <- compute_smoothed_state(input_stocks[,1],QML_params_stocks, outputKalman_stocks)
#f
n = 100; sigma_eta = .5; phi = .5
sigma = 1; theta_t = 1; y_t = 1 # change
perform_particlefilter_routine(n, sigma_eta, phi, sigma, theta_t, y_t)
